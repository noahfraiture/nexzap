// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: main.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const findCorrectionSheet = `-- name: FindCorrectionSheet :many
SELECT
  tu.title, -- debug log
  s.page, -- debug log
  s.submission_name,
  s.correction_content,
  s.docker_image,
  s.command,
  array_agg(f.name)::text[] AS files_name,
  array_agg(f.content)::text[] AS files_content
FROM
  sheets s
  JOIN files f ON f.sheet_id = s.id
  JOIN tutorials tu ON tu.id = s.tutorial_id
GROUP BY
  tu.title, s.id, s.docker_image, s.command, s.submission_name, s.correction_content
`

type FindCorrectionSheetRow struct {
	Title             string
	Page              int32
	SubmissionName    string
	CorrectionContent string
	DockerImage       string
	Command           string
	FilesName         []string
	FilesContent      []string
}

func (q *Queries) FindCorrectionSheet(ctx context.Context) ([]FindCorrectionSheetRow, error) {
	rows, err := q.db.Query(ctx, findCorrectionSheet)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindCorrectionSheetRow
	for rows.Next() {
		var i FindCorrectionSheetRow
		if err := rows.Scan(
			&i.Title,
			&i.Page,
			&i.SubmissionName,
			&i.CorrectionContent,
			&i.DockerImage,
			&i.Command,
			&i.FilesName,
			&i.FilesContent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLastTutorialSheet = `-- name: FindLastTutorialSheet :one
SELECT
  tu.title,
  tu.code_editor,
  s.id,
  s.guide_content,
  s.exercise_content,
  s.page,
  s.submission_content,
  (SELECT COUNT(page) FROM sheets sh WHERE sh.tutorial_id = tu.id) as total_pages
FROM
  tutorials tu
  JOIN sheets s ON s.tutorial_id = tu.id
WHERE
  s.page = $1
  AND tu.unlock < NOW ()
ORDER BY
  tu.unlock DESC,
  tu.version DESC
LIMIT
  1
`

type FindLastTutorialSheetRow struct {
	Title             string
	CodeEditor        string
	ID                uuid.UUID
	GuideContent      string
	ExerciseContent   string
	Page              int32
	SubmissionContent string
	TotalPages        int64
}

func (q *Queries) FindLastTutorialSheet(ctx context.Context, page int32) (FindLastTutorialSheetRow, error) {
	row := q.db.QueryRow(ctx, findLastTutorialSheet, page)
	var i FindLastTutorialSheetRow
	err := row.Scan(
		&i.Title,
		&i.CodeEditor,
		&i.ID,
		&i.GuideContent,
		&i.ExerciseContent,
		&i.Page,
		&i.SubmissionContent,
		&i.TotalPages,
	)
	return i, err
}

const findSpecificCorrectionSheet = `-- name: FindSpecificCorrectionSheet :one
SELECT
  s.submission_name,
  s.correction_content,
  s.docker_image,
  s.command,
  array_agg(f.name)::text[] AS files_name,
  array_agg(f.content)::text[] AS files_content
FROM
  sheets s
  JOIN files f ON f.sheet_id = s.id
  JOIN tutorials tu ON tu.id = s.tutorial_id
WHERE
  tu.title = $1 AND s.page = $2
GROUP BY
  tu.title, s.id, s.docker_image, s.command, s.submission_name, s.correction_content
`

type FindSpecificCorrectionSheetParams struct {
	Title string
	Page  int32
}

type FindSpecificCorrectionSheetRow struct {
	SubmissionName    string
	CorrectionContent string
	DockerImage       string
	Command           string
	FilesName         []string
	FilesContent      []string
}

func (q *Queries) FindSpecificCorrectionSheet(ctx context.Context, arg FindSpecificCorrectionSheetParams) (FindSpecificCorrectionSheetRow, error) {
	row := q.db.QueryRow(ctx, findSpecificCorrectionSheet, arg.Title, arg.Page)
	var i FindSpecificCorrectionSheetRow
	err := row.Scan(
		&i.SubmissionName,
		&i.CorrectionContent,
		&i.DockerImage,
		&i.Command,
		&i.FilesName,
		&i.FilesContent,
	)
	return i, err
}

const findSubmissionData = `-- name: FindSubmissionData :one
SELECT
  s.docker_image,
  s.command,
  s.submission_name,
  array_agg(f.name)::text[] AS files_name,
  array_agg(f.content)::text[] AS files_content
FROM
  sheets s
  JOIN files f ON f.sheet_id = s.id
WHERE
  s.id = $1
GROUP BY
  s.id, s.docker_image, s.command, s.submission_name
`

type FindSubmissionDataRow struct {
	DockerImage    string
	Command        string
	SubmissionName string
	FilesName      []string
	FilesContent   []string
}

func (q *Queries) FindSubmissionData(ctx context.Context, sheetID uuid.UUID) (FindSubmissionDataRow, error) {
	row := q.db.QueryRow(ctx, findSubmissionData, sheetID)
	var i FindSubmissionDataRow
	err := row.Scan(
		&i.DockerImage,
		&i.Command,
		&i.SubmissionName,
		&i.FilesName,
		&i.FilesContent,
	)
	return i, err
}

const insertFiles = `-- name: InsertFiles :exec
INSERT INTO files (name, content, sheet_id)
SELECT unnest($1::text[]), unnest($2::text[]), $3
`

type InsertFilesParams struct {
	Names    []string
	Contents []string
	SheetID  uuid.UUID
}

func (q *Queries) InsertFiles(ctx context.Context, arg InsertFilesParams) error {
	_, err := q.db.Exec(ctx, insertFiles, arg.Names, arg.Contents, arg.SheetID)
	return err
}

const insertTutorial = `-- name: InsertTutorial :many
WITH tutorial AS (
  INSERT INTO tutorials (title, code_editor, version, unlock)
  VALUES ($1, $2, $3, $4)
  ON CONFLICT (title, version) DO NOTHING -- TODO: check that
  RETURNING id
), sheet AS (
  INSERT INTO sheets (
    tutorial_id,
    page,
    guide_content,
    exercise_content,
    submission_name,
    submission_content,
    correction_content,
    docker_image,
    command
  )
  SELECT
    (SELECT id FROM tutorial),
    unnest($5::integer[]),
    unnest($6::text[]),
    unnest($7::text[]),
    unnest($8::text[]),
    unnest($9::text[]),
    unnest($10::text[]),
    unnest($11::text[]),
    unnest($12::text[])
  RETURNING id
)
SELECT id FROM sheet
`

type InsertTutorialParams struct {
	Title              string
	CodeEditor         string
	Version            int32
	Unlock             time.Time
	Pages              []int32
	GuidesContent      []string
	ExercisesContent   []string
	SubmissionsName    []string
	SubmissionsContent []string
	CorrectionContent  []string
	DockerImages       []string
	Commands           []string
}

func (q *Queries) InsertTutorial(ctx context.Context, arg InsertTutorialParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, insertTutorial,
		arg.Title,
		arg.CodeEditor,
		arg.Version,
		arg.Unlock,
		arg.Pages,
		arg.GuidesContent,
		arg.ExercisesContent,
		arg.SubmissionsName,
		arg.SubmissionsContent,
		arg.CorrectionContent,
		arg.DockerImages,
		arg.Commands,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
